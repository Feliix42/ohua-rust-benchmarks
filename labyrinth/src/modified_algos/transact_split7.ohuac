ns some_ns;

use sf crate::{is_not_empty, splitup, join};
use sf labyrinth::{increase, pack};
use sf labyrinth::grid::update_maze;
use sf labyrinth::pathfinder::find_path;

fn main(maze: Maze, to_map: Vec<(Point, Point)>) -> (Maze, u32) {
    transact(maze, to_map, 0)
}


fn transact(maze: Maze, to_map: Vec<(Point, Point)>, collision_count: u32) -> (Maze, u32) {
    let (tm1, tm2, tm3, tm4, tm5, tm6, tm7) = splitup(to_map);

    let part1 = for pair in tm1 {
        find_path(maze, pair)
    };
    let part2 = for pair in tm2 {
        find_path(maze, pair)
    };
    let part3 = for pair in tm3 {
        find_path(maze, pair)
    };
    let part4 = for pair in tm4 {
        find_path(maze, pair)
    };
    let part5 = for pair in tm5 {
        find_path(maze, pair)
    };
    let part6 = for pair in tm6 {
        find_path(maze, pair)
    };
    let part7 = for pair in tm7 {
        find_path(maze, pair)
    };

    let paths = join(part1, part2, part3, part4, part5, part6, part7);

    let (remap_paths, new_maze) = update_maze(maze, paths);

    let ct = increase(collision_count, remap_paths);
    let ret = pack(new_maze, collision_count);

    // simple check for len == 0
    if (is_not_empty(remap_paths)) {
        transact(new_maze, remap_paths, ct)
    } else {
        ret
    }
}
