ns some_ns;

use sf crate::is_empty;
use sf labyrinth::grid::update_maze;
use sf labyrinth::pathfinder::find_path;

// goal:

// f :: (StartPoint, EndPoint) -> Grid -> Path
// update :: Grid -> Path -> (Grid, ())
//
// transact :: [(Start, End)] -> (... -> ...) -> Grid -> Grid
// transact data f grid =
//     let paths = map (f grid) data in
//         let (paths, grid') = update grid paths in
//             if length paths == 0
//                 then grid'
//                 else transact paths f grid'

// IDEA: For now, don't track unmapped paths, just drop them
fn main(maze: Maze, to_map: Vec<(Point, Point)>) -> Maze {
    transact(maze, to_map)
}


fn transact(maze: Maze, to_map: Vec<(Point, Point)>) -> Maze {
    let paths = for pair in to_map {
        find_path(maze, pair)   // -> returns Option<Path>
    };       // -> Vec<Option<Path>>

    // returns (Vec<(Point, Point)>, Maze)  -- prunes optionals from previous vec!
    // also adds mapped paths to mapped vec
    let (remap_paths, new_maze) = update_maze(maze, paths);

    // simple check for len == 0
    if (is_empty(remap_paths)) {
        new_maze
    } else {
        transact(new_maze, remap_paths)
    }
}
