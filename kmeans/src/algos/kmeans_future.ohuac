ns kmeans;

use sf crate::{calc_centroids, collect_and_shutdown, inc, should_continue, spawn_onto_pool, splitup, unpack_updates};

// returns the number of runs
fn main(values: Vec<Value>, centroids: Vec<Centroid>, threshold: f32, threadcount: usize) -> u32 {
    run_kmeans(values, centroids, threshold, threadcount, 0)
}

fn run_kmeans(values: Vec<Value>, centroids: Vec<Centroid>, threshold: f32, threadcount: usize, iteration: u32) -> u32 {
    // let updates = for val in values {
    //     reassign_value(val, centroids)
    // };   // -> Vec<(Value, usize)>

    let split_values = splitup(values, threadcount);
    // threadpool erzeugen und threads spawnen, pool und handles zur√ºck
    let tokio_stuff = spawn_onto_pool(split_values, centroids, threadcount);

    // handles collecten, shutdown auf pool callen
    let updates = collect_and_shutdown(tokio_stuff);

    let (updated_values, current_delta) = unpack_updates(updates);
    // current_delta is already the final delta value, no division required

    let new_centroids = calc_centroids(updated_values, centroids);

    let next_iteration = inc(iteration);
    if should_continue(current_delta, threshold, iteration) {
        run_kmeans(updated_values, new_centroids, threshold, threadcount, next_iteration)
    } else {
        iteration
    }
}
